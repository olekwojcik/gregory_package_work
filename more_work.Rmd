---
title: "work 2"
output: pdf_document
---

```{r}
#load libraries and set seed
library(mase)
library(pdxTrees)
library(tidyverse)

set.seed(13)
```

```{r}
#load and wrangle data
dat <- get_pdxTrees_parks() %>%
  as.data.frame() %>%
  drop_na(DBH, Crown_Width_NS, Tree_Height) %>%
  filter(Condition != "Dead") %>%
  select(UserID, Tree_Height, Crown_Width_NS, DBH, Condition, Family)


dat_s <- dat %>%
  sample_n(1000) %>%
  as.data.frame()

dat <- dat %>%
  select(-Tree_Height)

dat_est <- dat %>%
  filter(Family == "Pinaceae")

predictors <- c("Crown_Width_NS", "DBH")

dat_x_bar <- dat %>%
  dplyr::group_by(Family) %>%
  dplyr::summarize(dplyr::across(predictors,
                                mean)) %>%
  tidyr::pivot_longer(!Family,
                            names_to = "variable",
                            values_to = "mean")

dat_count_est <- dat %>%
  group_by(Family) %>%
  summarize(count = n())

dat_prop <- left_join(dat, dat_count_est, by = "Family") %>%
  group_by(Condition, Family) %>%
  summarize(prop = n()/count) %>%
  distinct() %>%
  ungroup()


dat_x_means <- get_pdxTrees_parks() %>%
  as.data.frame() %>%
  drop_na(DBH, Crown_Width_NS, Tree_Height) %>%
  dplyr::summarize(DBH = mean(DBH), Crown_Width_NS = mean(Crown_Width_NS), 
            Tree_Height = mean(Tree_Height))
```


```{r}
#mase

est <- greg(y = dat_s$Tree_Height, x_sample =  dat_s[c("Crown_Width_NS", "DBH", "Condition")],
            x_pop = dat[c("Crown_Width_NS", "DBH", "Condition")],
            data_type = "raw")

est$pop_mean

est$pop_mean_var




est <- greg(y = dat_s$Tree_Height, x_sample =  dat_s[ c("Crown_Width_NS", "DBH")],
            x_pop = dat_x_means, var_est = TRUE,
            data_type = "means", N = 25271)
#est
```


$$\pmb{\beta}^*_l = \pmb{\beta}_l  w_l$$
$$\bar{y} + \sum_{l \in p} (\pmb{\bar{x}}^T_N\pmb{\beta}^*_l - \pmb{\bar{x}}^T_n\pmb{\beta}^*_l)$$


$$\bar{y} + \sum_{l \in p} w_l(\pmb{\bar{x}}^T_N\pmb{\beta}_l - \pmb{\bar{x}}^T_n\pmb{\beta}_l)$$



```{r, warning = F, message=F}
gregory <- function(y, #vector of response variable (BALIVE)
                    x_sample, #sample "plot" data, total_data, without y, with res and est
                    x_pop, #means, columns are estimation, "variable" and "mean"
                    resolution, #character, column name of resolution unit in dfs
                    estimation, # character, column name of estimation unit in dfs
                    y_est_name, #character of what "county" we want to estimate,
                    prop, # dataframe, columns: resolution, estimation, and "prop"
                    formula = FALSE # optional, specify formula or leave F for everything
){
  options(warn = -1)
  #first attatch y to x_sample for easy wrangling
  
  
  neo_x_sample <- x_sample %>%
    dplyr::mutate(y_variable = y)
  

  
  #find y bar by filtering to estimation unit of interest
  
  y_bar_df <- neo_x_sample %>%
    dplyr::filter(.data[[estimation]] == y_est_name) %>%
    summarize(mean = mean(y_variable))
  
  y_bar <- y_bar_df$mean[[1]]
  
  #use proportions to filter out only RUs that we care about
  
  res_units_df <- prop %>%
    select(-prop)
  
  res_units <- dplyr::pull(res_units_df)
  
  
  neo_x_pop <- x_pop 
  
  #now we can make the betas off of neo_x_sample
  
  if(formula == FALSE){
    #if formula is not provided
    predictors <-  unique(dplyr::pull(neo_x_pop, variable))
    
    

    
     betas <- res_units %>%
      purrr::map_dfr(.f = function(.){
        
        #this is to avoid weird bug
        period_two <- .
        
        x_sample_filtered <- neo_x_sample %>%
          dplyr::filter(.data[[resolution]] == period_two)

        
        model <- lm(as.formula(c(paste("y_variable", "~"),
                        paste(predictors, collapse = " + "))),
           data = x_sample_filtered)
        

        
        result <- data.frame(resolution = .,
                             variable = names(model$coefficients),
                             beta = unname(model$coefficients))
        
        names(result)[[1]] <- resolution
        
        return(result)
        
      })
  }
  

  
  if(formula != FALSE){
    #if formula is provided
     betas <- res_units %>%
      purrr::map_dfr(.f = function(.){
        
        #this is to avoid weird bug
        period_two <- .
        
        x_sample_filtered <- x_sample %>%
          dplyr::filter(.data[[resolution]] == period_two)
        
        model <- lm(formula,
           data = neo_x_sample)
        
        result <- data.frame(resolution = .,
                             variable = names(model$coefficients),
                             beta = unname(model$coefficients))
        
        names(result)[[1]] <- resolution
        
        return(result)
        
      })
  }
  

  #join x bar little n
  math_df <- dplyr::left_join(betas, x_pop, by = "variable") %>%
    dplyr::rename(mean_n = mean)
  
  #join x bar big n
    tidy_x_sample <- x_sample %>%
    tidyr::pivot_longer(!c(.data[[resolution]], .data[[estimation]]),
                 names_to = "variable",
                 values_to = "value") %>%
      dplyr::filter(.data[[estimation]] == y_est_name) %>%
      group_by(variable) %>%
      summarize(mean_N = mean(value))
    
  math_df <- dplyr::left_join(math_df, tidy_x_sample, by = "variable") %>%
    left_join(prop, by = resolution)
  
  
  math_df[is.na(math_df)] <- 1

  result <- math_df %>%
    dplyr::mutate(weighted_beta = beta * prop) %>%
    dplyr::mutate(matrix_term_n = mean_n * weighted_beta,
                  matrix_term_N = mean_N * weighted_beta) %>%
    group_by(.data[[resolution]]) %>%
    summarize(matrix_term_n = sum(matrix_term_n),
              matrix_term_N = sum(matrix_term_N)) %>%
    dplyr::mutate(sum_difference = -matrix_term_N + matrix_term_n) %>%
    ungroup() %>%
    dplyr::summarize(answer = sum(sum_difference))
  
  
  

  return(y_bar + result$answer[[1]])
  
}

gregory(y = dat_s$Tree_Height,
        x_sample = dat_s[c("Crown_Width_NS", "DBH", "Condition", "Family")],
        x_pop = dat_x_bar %>% filter(Family == "Pinaceae") %>% select(-Family),
        resolution = "Condition",
        estimation = "Family",
        y_est_name = "Pinaceae",
        prop = dat_prop %>% filter(Family == "Pinaceae") %>% select(-Family)) 

#hello
```




Gregory all function


```{r}

get_beta <- function(plot_df){
  
}

gregory_all <- function(
  plot_df, #all plot data (totaldata)
  resolution, #character, name of resolution in dfs
  estimation, #character, name of estimation in dfs
  pixel_estimation_means, #means of predictors per plot df
  proportions, #estimation resolution prop df
  formula, #formula for model
  prop #character, name of percent
){
  
  
  #i want to get betas for every province
  #so first make a list of the provinces
  
  provinces <- proportions %>%
    dplyr::select(.data[[resolution]]) %>%
    dplyr::pull() %>%
    unique()
  
  #get betas for each province
  
  betas <- provinces %>%
      purrr::map_dfr(.f = function(.){
        
        #this is to avoid weird bug
        period_two <- .
        
        x_sample_filtered <- plot_df %>%
          dplyr::filter(.data[[resolution]] == period_two)

        
        model <- lm(formula,
                    data = x_sample_filtered)
        

        
        result <- data.frame(resolution = .,
                             variable = names(model$coefficients),
                             beta = unname(model$coefficients))
        
        names(result)[[1]] <- resolution
        
        return(result)
        
      })
  
  #now let's get those predictors
  
  predictors <- betas  %>%
    dplyr::select(variable) %>%
    dplyr::pull() %>%
    unique()
  
  predictors <- predictors[!predictors %in% "(Intercept)"]
  
  
  #now let's get the weighted betas
  
  weighted_beta_df <- dplyr::left_join(proportions, betas, by = resolution) %>%
    dplyr::mutate(weighted_beta = beta * .data[[prop]]) %>%
    dplyr::select(.data[[estimation]],
                  .data[[resolution]],
                  variable,
                  weighted_beta)
  
  
  #now lets pivot the n means(maybe ask for this as input?)
  
  
  N_df <- dplyr::select(pixel_estimation_means,
                           c(estimation, predictors))
  
  N_df <- tidyr::pivot_longer(N_df, !.data[[estimation]],
                                 names_to = "variable",
                                 values_to = "mean_N")
  
  #now combine with betas
  
  term_df <- left_join(weighted_beta_df, N_df, by = c(estimation, "variable"))
  
  #now let's get the N means
  
  n_df <- plot_df %>%
    dplyr::group_by(.data[[estimation]]) %>%
    dplyr::summarize(across(predictors, mean)) %>%
    tidyr::pivot_longer(!.data[[estimation]],
                        names_to = "variable",
                        values_to = "mean_n")
  
  #then join N to the term_df
  
  term_df <- left_join(term_df, n_df, by = c(estimation, "variable"))
  
  
  
  #replace na's from join (intercept) with 1's
  
  term_df$mean_n[is.na(term_df$mean_n)] <- 1
  term_df$mean_N[is.na(term_df$mean_N)] <- 1
  
  
  term_df <- term_df %>%
    mutate(term_n = weighted_beta * mean_n,
           term_N = weighted_beta * mean_N) %>%
    group_by(.data[[estimation]]) %>%
    summarize(term_n = sum(term_n),
              term_N = sum(term_N)) %>%
    mutate(term = term_N - term_n) %>%
    select(fips, term)
  
  #get Y var
  
  y <- all.vars(formula)[1]

  
  #get y_bars
  
  y_bar_df <- plot_df %>%
    dplyr::group_by(.data[[estimation]]) %>%
    summarize(y_bar = mean(.data[[y]]))
  
  #join with the rest and get the final result
  
  result <- left_join(term_df, y_bar_df, by = estimation) %>%
    dplyr::mutate(estimate = y_bar + term) %>%
    dplyr::select(.data[[estimation]], estimate)
  
  return(result)
  
  
  
}

gregory_all(plot_df = total_data %>% mutate(fips = as.numeric(fips)),
            resolution = "eco_pro_code",
            estimation = "fips",
            pixel_estimation_means = pixel_county_new,
            proportions = province_proportions,
            formula = BALIVE_TPA ~ forbio,
            prop = "percent")



```




```{r}
greg_all <- function(plot_df,
                     estimation,
                     pixel_estimation_means,
                     formula
){
  #i want to get betas for every county
  #so first make a list of the counties
  
  counties <- plot_df %>%
    dplyr::select(.data[[estimation]]) %>%
    dplyr::pull() %>%
    unique()
  
  #get betas for each county
  
  
  betas <- counties %>%
      purrr::map_dfr(.f = function(.){
        
        #this is to avoid weird bug
        period_two <- .
        
        x_sample_filtered <- plot_df %>%
          dplyr::filter(.data[[estimation]] == period_two)

        
        model <- lm(formula,
                    data = x_sample_filtered)
        

        
        result <- data.frame(estimation = .,
                             variable = names(model$coefficients),
                             beta = unname(model$coefficients))
        
        names(result)[[1]] <- estimation
        
        return(result)
        
      })

  
  #now let's get those predictors
  
  predictors <- betas  %>%
    dplyr::select(variable) %>%
    dplyr::pull() %>%
    unique()
  
  predictors <- predictors[!predictors %in% "(Intercept)"]
  
    #now lets pivot the n means(maybe ask for this as input?)
  
  
  N_df <- dplyr::select(pixel_estimation_means,
                           c(estimation, predictors))
  
  N_df <- tidyr::pivot_longer(N_df, !.data[[estimation]],
                                 names_to = "variable",
                                 values_to = "mean_N")
  
  #now combine with betas
  
  term_df <- left_join(betas, N_df, by = c(estimation, "variable"))
  
  #now let's get the N means
  
  n_df <- plot_df %>%
    dplyr::group_by(.data[[estimation]]) %>%
    dplyr::summarize(across(predictors, mean)) %>%
    tidyr::pivot_longer(!.data[[estimation]],
                        names_to = "variable",
                        values_to = "mean_n")
  
  #then join N to the term_df
  
  term_df <- left_join(term_df, n_df, by = c(estimation, "variable"))
  
  
  
  #replace na's from join (intercept) with 1's
  
  term_df$mean_n[is.na(term_df$mean_n)] <- 1
  term_df$mean_N[is.na(term_df$mean_N)] <- 1
  
  
  term_df <- term_df %>%
    mutate(term_n = beta * mean_n,
           term_N = beta * mean_N) %>%
    group_by(.data[[estimation]]) %>%
    summarize(term_n = sum(term_n),
              term_N = sum(term_N)) %>%
    mutate(term = term_N - term_n) %>%
    select(fips, term)
  
  #get Y var
  
  y <- all.vars(formula)[1]

  
  #get y_bars
  
  y_bar_df <- plot_df %>%
    dplyr::group_by(.data[[estimation]]) %>%
    summarize(y_bar = mean(.data[[y]]))
  
  #join with the rest and get the final result
  
  result <- left_join(term_df, y_bar_df, by = estimation) %>%
    dplyr::mutate(estimate = y_bar + term) %>%
    dplyr::select(.data[[estimation]], estimate)
  
  return(result)
}

greg_all(plot_df = total_data %>% mutate(fips = as.numeric(fips)),
         estimation = "fips",
         pixel_estimation_means = pixel_county_new,
         formula = BALIVE_TPA ~ forbio)
```

# Sam Testing (Ensure it runs)

```{r}
pixel_mean <- pixel_county %>% 
  mutate(forbio = mean_forbio)%>%
  select(fips, forbio)
province_proportions_new <- province_proportions %>%
  mutate(eco_pro_code = province) %>%
  select(-province)
gregory_all(plot_df = total_data %>% mutate(fips = as.numeric(fips)),
            resolution = "eco_pro_code",
            estimation = "fips",
            pixel_estimation_means = pixel_mean,
            proportions = province_proportions_new,
            formula = BALIVE_TPA ~ forbio,
            prop = "percent")
# Error: Column `eco_pro_code` not found in `.data`
# Solution: Rename province to 'eco_pro_code' in province_proportions

# Error: Can't subset columns that don't exist. x Column `forbio` doesn't exist.
# Solution: Rename mean to forbio in pixel_mean, rename column for variable name

# Potential Issue: for Daggett (49009), estimate is
# 49009	85.632791292	
# Expect ~60
# Note: Could be from using inappropriate data source (means or proportions)

# From Older GREGORY function (this summer) 
# 85.63279

# From Oldest GREGORY function (last summer)
# 60.92363
```

```{r old}
x1 <- gregory_old(df_plots = total_data %>% rename(province = eco_pro_code) %>% mutate(fips = as.numeric(fips)) %>% filter(fips != 8014),
        y_plot = BALIVE_TPA,
        x_plot = c("forbio"),
        df_means = pixel_mean %>% mutate(fips = as.numeric(fips)) %>% filter(fips != 8014) %>% rename(mean = forbio),
        x_means = c("mean"),
        df_props = province_proportions %>% rename(province = eco_pro_code) %>% mutate(fips = as.numeric(fips)) %>% filter(fips != 8014),
        prop = percent,
        estimation = fips,
        resolution = province)
# 49009
# 60.02256
```

Commentary: After getting all 3 versions to work, I will now move into timing and comparing the timing. 

However, we should note that our newer functions still do not agree on the estimates values, as noted in the commented-out chunk above

```{r}
# Time Experiment

# OLD GREGORY
start.time1 <- Sys.time()
invisible(rep(gregory_old(df_plots = total_data_old,
         y_plot = BALIVE_TPA,
         x_plot = c("forbio"),
         df_means = pixel_means_old,
         x_means = c("mean_forbio"),
         df_props = province_proportions_old,
         prop = percent,
         estimation = fips,
         resolution = province), 100))

end.time1 <- Sys.time()
time.taken1 <- end.time1 - start.time1
# GREGORY ALL
start.time2 <- Sys.time()
invisible(rep(gregory_all(plot_df = total_data %>% mutate(fips = as.numeric(fips)),
            resolution = "eco_pro_code",
            estimation = "fips",
            pixel_estimation_means = pixel_mean,
            proportions = province_proportions_new,
            formula = BALIVE_TPA ~ forbio,
            prop = "percent"), 100))

end.time2 <- Sys.time()
time.taken2 <- end.time2 - start.time2

# Positive means new function faster
# Negative means old function faster
time.taken2 - time.taken1
```



$$\pmb{\beta}^*_l = \pmb{\beta}_l  w_l$$

$$\bar{y} + \sum_{l \in p} (\pmb{\bar{x}}^T_N\pmb{\beta}^*_l - \pmb{\bar{x}}^T_n\pmb{\beta}^*_l)$$








